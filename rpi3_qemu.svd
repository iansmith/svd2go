<?xml version="1.0" encoding="utf-8"?>
<!--
  Raspberry PI 3 B+, System View Description

  Sources:
  BCM2835 ARM Peripherals Datasheet
  https://elinux.org/BCM2835_datasheet_errata
  qemu 5.0.0 source code

 -->

<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd" >
  <vendor>Raspberr Pi Foundation</vendor>
  <vendorID>RPI</vendorID>
  <name>rpi3b</name>
  <series>raspberry pi</series>
  <version>0.1</version>
  <description>Single Board Computer With An ARM A-53 Quad Core CPU in a BCM2837 SOC</description>
  <licenseText>
MIT License

Copyright (c) 2020 Ian Smith

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
  </licenseText>
  <cpu>                                                           <!-- details about the cpu embedded in the device -->
    <name>CA53</name>
    <revision>r3p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>0</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
    <fpuDP>false</fpuDP>
    <dspPresent>false</dspPresent>
    <icachePresent>true</icachePresent>
    <dcachePresent>true</dcachePresent>
  </cpu>

  <peripherals>
    <peripheral>
        <name>Auxillaries</name>
        <description>
        The Device has three Auxiliary peripherals: One mini UART and two SPI masters.
        These three peripheral are grouped together as they share the same area in the
        peripheral register map and they share a common interrupt. Also all three are
        controlled by the auxiliary enable register.
        </description>
        <addressBlock>
            <baseAddress>0x215000</baseAddress>
            <size>0x68</size>
            <usage>registers</usage>
        </addressBlock>
        <headerStructName>Aux</headerStructName>
        <registers>
            <register>
                <name>IRQ</name>
                <description>The AUXIRQ register is used to check any pending interrupts which may be
                asserted by the three Auxiliary sub blocks.</description>
                <addressOffset>0</addressOffset>
                <size>3</size>
                <fields>
                    <field>
                        <name>Spi2IRQ</name>
                        <description>If set the SPI 2 module has an interrupt pending.</description>
                        <bitRange>[2:2]</bitRange>
                        <access>read-only</access>
                        <resetValue>0</resetValue>
                    </field>
                    <field>
                        <name>Spi1IRQ</name>
                        <description>If set the SPI 1 module has an interrupt pending.</description>
                        <bitRange>[1:1]</bitRange>
                        <access>read-only</access>
                        <resetValue>0</resetValue>
                    </field>
                    <field>
                        <name>MiniUARTIRQ</name>
                        <description>If set the Mini UART module has an interrupt pending.</description>
                        <bitRange>[0:0]</bitRange>
                        <access>read-only</access>
                        <resetValue>0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>Enable</name>
                <description>The AUXENB register is used to enable the three modules; UART, SPI1, SPI2.</description>
                <addressOffset>0x4</addressOffset>
                <size>3</size>
                <fields>
                    <field>
                        <name>Spi2Enable</name>
                        <description>
                            If set the SPI 2 module is enabled.
                            If clear the SPI 2 module is disabled.
                            That also disables any SPI 2 module register access
                        </description>
                        <bitRange>[2:2]</bitRange>
                        <access>read-write</access>
                        <resetValue>0</resetValue>
                    </field>
                    <field>
                        <name>Spi1Enable</name>
                        <description>
                            If set the SPI 1 module is enabled.
                            If clear the SPI 1 module is disabled.
                            That also disables any SPI 1 module register access
                        </description>
                        <bitRange>[1:1]</bitRange>
                        <access>read-write</access>
                        <resetValue>0</resetValue>
                    </field>
                    <field>
                        <name>MiniUARTEnable</name>
                        <description>
                            If set the mini UART is enabled. The UART will immediately start receiving data, especially if the UART1_RX line is low.
                            If clear the mini UART is disabled. That also disables any mini UART register access
                        </description>
                        <bitRange>[0:0]</bitRange>
                        <access>read-write</access>
                        <resetValue>0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTData</name>
                <description>
                    The AUX_MU_IO_REG register is primary used to write data to and read data from the UART FIFOs.
                    If the DLAB bit in the line control register is set this register gives access to the LS 8 bits of the baud rate. (Note: there is easier access to the baud rate register)
                </description>
                <addressOffset>0x40</addressOffset>
                <size>8</size>
                <fields>
                    <field>
                        <name>Tx</name>
                        <description>Data written is put in the transmit FIFO (Provided it is not full)</description>
                        <bitRange>[7:0]</bitRange>
                        <access>write-only</access>
                        <resetValue>0</resetValue>
                    </field>
                    <field>
                        <name>Rx</name>
                        <description>Data written is put in the transmit FIFO (Provided it is not full)</description>
                        <bitRange>[7:0]</bitRange>
                        <access>read-only</access>
                        <resetValue>0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTInterruptEnable</name>
                <description>The AUX_MU_IER_REG register is primary used to enable interrupts</description>
                <addressOffset>0x44</addressOffset>
                <size>2</size>
                <fields>
                    <field>
                        <name>Interrupts</name>
                        <description>Enable or Disable Interrupts For Receive and Transmit</description>
                        <bitRange>[3:0]</bitRange>
                        <access>read-write</access>
                        <resetValue>0</resetValue>
                        <enumeratedValues>
                            <enumeratedValue>
                                <name>None</name>
                                <value>0b0000</value>
                                <description>Turn off Receive and Transmit interrupts</description>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>Receive</name>
                                <value>0b0101</value>
                                <description>Send interrupt when at least one symbol is available in receive FIFO</description>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>Transmit</name>
                                <value>0b1010</value>
                                <description>Send interrupt when the transmit FIFO is empty</description>
                            </enumeratedValue>
                        </enumeratedValues>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTInterruptStatus</name>
                <description>
                    The AUX_MU_IIR_REG register shows the interrupt status.
                    It also has two FIFO enable status bits and (when writing) FIFO clear bits.</description>
                <addressOffset>0x48</addressOffset>
                <size>8</size>
                <fields>
                    <field>
                        <name>FIFOEnables</name>
                        <description>
                            Both bits always read as 1 as the FIFOs are always enabled
                        </description>
                        <bitRange>[7:6]</bitRange>
                        <access>read-only</access>
                        <resetValue>0b11</resetValue>
                    </field>
                    <field>
                        <name>InterruptID</name>
                        <description>
                            On read this register shows the interrupt ID bit
                        </description>
                        <bitRange>[2:1]</bitRange>
                        <access>read-only</access>
                        <resetValue>0b00</resetValue>
                        <enumeratedValues>
                            <name></name>
                            <usage>read-only</usage>
                            <enumeratedValue>
                                <name>NoInterrupts</name>
                                <value>0b00</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>TransmitEmpty</name>
                                <description>Transmit holding register empty</description>
                                <value>0b01</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>ReceiverReady</name>
                                <description>Receiver holds valid byte</description>
                                <value>0b10</value>
                            </enumeratedValue>
                        </enumeratedValues>
                    </field>
                    <field>
                        <name>FIFOClear</name>
                        <description>
                            On write, writing with bit 1 set will clear the receive FIFO Writing with bit 2 set will clear the transmit FIFO
                        </description>
                        <bitRange>[2:1]</bitRange>
                        <access>write-only</access>
                        <resetValue>0b00</resetValue>
                        <enumeratedValues>
                            <name></name>
                            <usage>write-only</usage>
                            <enumeratedValue>
                                <name>Transmit</name>
                                <value>0b01</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>Receive</name>
                                <value>0b10</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>TransmitAndReceive</name>
                                <value>0b11</value>
                            </enumeratedValue>
                        </enumeratedValues>
                    </field>
                    <field>
                        <name>InterruptPending</name>
                        <description>This bit is clear whenever an interrupt is pending</description>
                         <bitRange>[0:0]</bitRange>
                        <access>read-only</access>
                        <resetValue>0b1</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTLineControl</name>
                <description>
                    The AUX_MU_LCR_REG register controls the line data format.
                </description>
                <addressOffset>0x4C</addressOffset>
                <size>7</size>
                <fields>
                    <field>
                        <name>Break</name>
                        <bitRange>[6:6]</bitRange>
                        <description>
                            If set high the UART1_TX line is pulled low continuously.
                            If held for at least 12 bits times that will indicate a break condition.
                        </description>
                        <access>read-write</access>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>DataSize</name>
                        <description>
                            If clear the UART works in 7-bit mode If set the UART works in 8-bit mode.
                            The documentation in the data sheet is actually wrong on this one, so
                            I used the known to work values.
                        </description>
                        <bitRange>[1:0]</bitRange>
                        <access>read-write</access>
                        <resetValue>0b0</resetValue>
                        <enumeratedValues>
                            <enumeratedValue>
                                <name>SevenBit</name>
                                <value>0b00</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>EightBit</name>
                                <value>0b11</value>
                            </enumeratedValue>
                        </enumeratedValues>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTModemControl</name>
                <description>
                    The AUX_MU_MCR_REG register controls the 'modem' signals.
                </description>
                <addressOffset>0x50</addressOffset>
                <size>2</size>
                <fields>
                    <field>
                        <name>RTS</name>
                        <description>
                            If clear the UART1_RTS line is high If set the UART1_RTS line is low.
                            This bit is ignored if the RTS is used for auto-flow control
                            (See the Mini Uart Extra Control register description).
                        </description>
                        <access>read-write</access>
                        <bitRange>[1:1]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTLineStatus</name>
                <description>
                    The AUX_MU_LSR_REG register shows the data status.
                </description>
                <addressOffset>0x54</addressOffset>
                <size>7</size>
                <fields>
                    <field>
                        <name>TransmitterIdle</name>
                        <description>
                            This bit is set if the transmit FIFO is empty and the transmitter is idle. (Finished shifting out the last bit).
                        </description>
                        <access>read-only</access>
                        <bitRange>[6:6]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                    <field>
                        <name>TransmitterEmpty</name>
                        <description>
                            This bit is set if the transmit FIFO can accept at least one byte.
                        </description>
                        <access>read-only</access>
                        <bitRange>[5:5]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>ReceiverOverrun</name>
                        <description>
                            This bit is set if there was a receiver overrun. That is: one or more characters arrived whilst the receive FIFO was full. The newly arrived charters have been discarded. This bit is cleared each time this register is read. To do a non-destructive read of this overrun bit use the Mini Uart Extra Status register.
                        </description>
                        <access>read-only</access>
                        <bitRange>[1:1]</bitRange>
                        <readAction>clear</readAction>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>DataReady</name>
                        <description>
                            This bit is set if the receive FIFO holds at least 1 symbol.
                        </description>
                        <access>read-only</access>
                        <bitRange>[0:0]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTModemStatus</name>
                <description>
                    The AUX_MU_MSR_REG register shows the 'modem' status.
                </description>
                <addressOffset>0x58</addressOffset>
                <size>6</size>
                <fields>
                    <field>
                        <name>CTS</name>
                        <description>
                            This bit is the inverse of the UART1_CTS input Thus :
                            If set the UART1_CTS pin is low
                            If clear the UART1_CTS pin is high
                        </description>
                        <access>read-only</access>
                        <bitRange>[5:5]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTScratch</name>
                <description>
                    AUX_MU_SCRATCH is a single byte storage.
                </description>
                <addressOffset>0x5C</addressOffset>
                <size>8</size>
                <fields>
                    <field>
                        <name>Scratch</name>
                        <description>
                            One whole byte extra on top of the 134217728 provided by the SDC
                        </description>
                        <access>read-write</access>
                        <bitRange>[7:0]</bitRange>
                        <resetValue>0x0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTExtra</name>
                <description>
                    The AUX_MU_CNTL_REG provides access to some extra useful and nice features not found on a normal 16550 UART .
                </description>
                <addressOffset>0x60</addressOffset>
                <size>8</size>
                <fields>
                    <field>
                        <name>CTSAssertLevel</name>
                        <description>
                            This bit allows one to invert the CTS auto flow operation polarity.
                            If set the CTS auto flow assert level is low*
                            If clear the CTS auto flow assert level is high*
                        </description>
                        <access>read-write</access>
                        <bitRange>[7:7]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>RTSAssertLevel</name>
                        <description>
                            This bit allows one to invert the RTS auto flow operation polarity.
                            If set the RTS auto flow assert level is low*
                            If clear the RTS auto flow assert level is high*
                        </description>
                        <access>read-write</access>
                        <bitRange>[6:6]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>RTSAutoFlowLevel</name>
                        <description>
                           These two bits specify at what receiver FIFO level the RTS line is de-asserted in auto-flow mode.
                        </description>
                        <access>read-write</access>
                        <bitRange>[5:4]</bitRange>
                        <resetValue>0b0</resetValue>
                        <enumeratedValues>
                            <enumeratedValue>
                                <name>DeassertRTSWith3Empty</name>
                                <value>0b00</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>DeassertRTSWith2Empty</name>
                                <value>0b01</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>DeassertRTSWith1Empty</name>
                                <value>0b10</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>DeassertRTSWith4Empty</name>
                                <value>0b11</value>
                            </enumeratedValue>
                        </enumeratedValues>
                    </field>
                    <field>
                        <name>EnableTransmitAutoFlowControl</name>
                        <description>
                           If this bit is set the transmitter will stop if the CTS line is de-asserted.
                           If this bit is clear the transmitter will ignore the status of the CTS line
                        </description>
                        <access>read-write</access>
                        <bitRange>[3:3]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>EnableReceiveAutoFlowControl</name>
                        <description>
                            If this bit is set the RTS line will de-assert if the receive FIFO reaches it 'auto flow' level. In fact the RTS line will behave as an RTR (Ready To Receive) line.
                            If this bit is clear the RTS line is controlled by the AUX_MU_MCR_REG register bit 1.
                        </description>
                        <access>read-write</access>
                        <bitRange>[2:2]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>TransmitterEnable</name>
                        <description>
                            If this bit is set the mini UART transmitter is enabled.
                            If this bit is clear the mini UART transmitter is disabled
                        </description>
                        <access>read-write</access>
                        <bitRange>[1:1]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                    <field>
                        <name>ReceiverEnable</name>
                        <description>
                            If this bit is set the mini UART receiver is enabled. If this bit is clear the mini UART receiver is disabled
                        </description>
                        <access>read-write</access>
                        <bitRange>[0:0]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTStatus</name>
                <description>
                    The AUX_MU_STAT_REG provides a lot of useful information about the internal status of the mini UART not found on a normal 16550 UART.
                </description>
                <addressOffset>0x64</addressOffset>
                <size>28</size>
                <fields>
                    <field>
                        <name>TransmitFIFOFillLevel</name>
                        <description>
                            These bits shows how many symbols are stored in the transmit FIFO.
                            The value is in the range 0-8.
                        </description>
                        <access>read-only</access>
                        <bitRange>[27:24]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>ReceiveFIFOFillLevel</name>
                        <description>
                            These bits shows how many symbols are stored in the receive FIFO.
                            The value is in the range 0-8.
                        </description>
                        <access>read-only</access>
                        <bitRange>[19:16]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>TransmitterDone</name>
                        <description>
                            This bit is set if the transmitter is idle and the transmit FIFO is empty.
                        </description>
                        <access>read-only</access>
                        <bitRange>[9:9]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                    <field>
                        <name>TransmitFIFOEmpty</name>
                        <description>
                            If this bit is set the transmitter FIFO is empty. Thus it can accept 8 symbols
                        </description>
                        <access>read-only</access>
                        <bitRange>[8:8]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                    <field>
                        <name>CTSStatus</name>
                        <description>
                            This bit shows the status of the UART1_CTS line.
                        </description>
                        <access>read-only</access>
                        <bitRange>[7:7]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>RTSStatus</name>
                        <description>
                            This bit shows the status of the UART1_RTS line.
                        </description>
                        <access>read-only</access>
                        <bitRange>[6:6]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>TransmitFIFOFull</name>
                        <description>
                            If this bit is set the transmitter FIFO is full.
                        </description>
                        <access>read-only</access>
                        <bitRange>[5:5]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>ReceiverOverrun</name>
                        <description>
                            This bit is set if there was a receiver overrun. That is: one or more characters arrived whilst the receive FIFO was full. The newly arrived characters have been discarded. This bit is cleared each time the AUX_MU_LSR_REG register is read.
                        </description>
                        <access>read-only</access>
                        <bitRange>[4:4]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>TransmitterIdle</name>
                        <description>
                            If this bit is set the transmitter is idle. If this bit is clear the transmitter is idle [??busy??].
                        </description>
                        <access>read-only</access>
                        <bitRange>[3:3]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                    <field>
                        <name>ReceiverIdle</name>
                        <description>
                            If this bit is set the receiver is idle.
                            If this bit is clear the receiver is busy.
                            This bit can change unless the receiver is disabled.
                        </description>
                        <access>read-only</access>
                        <bitRange>[2:2]</bitRange>
                        <resetValue>0b1</resetValue>
                    </field>
                    <field>
                        <name>SpaceAvailable</name>
                        <description>
                            If this bit is set the mini UART transmitter FIFO can accept at least one more symbol.
                            If this bit is clear the mini UART transmitter FIFO is full.
                        </description>
                        <access>read-only</access>
                        <bitRange>[1:1]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                    <field>
                        <name>SymbolAvailable</name>
                        <description>
                            If this bit is set the mini UART receive FIFO contains at least 1 symbol
                            If this bit is clear the mini UART receiver FIFO is empty
                        </description>
                        <access>read-only</access>
                        <bitRange>[0:0]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>MiniUARTBaud</name>
                <description>
                    The AUX_MU_BAUD register allows direct access to the 16-bit wide baudrate counter.
                </description>
                <addressOffset>0x68</addressOffset>
                <size>16</size>
                <fields>
                    <field>
                        <name>BaudrateCounter</name>
                        <access>read-write</access>
                        <bitRange>[15:0]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                </fields>
            </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>Timers</name>
        <description>
        A free running, 64 bit timer and 2 (ne√© 4) match registers.
        </description>
        <addressBlock>
            <baseAddress>0x3000</baseAddress>
            <size>0x1C</size>
            <usage>registers</usage>
        </addressBlock>
        <headerStructName>Timers</headerStructName>
        <registers>
            <register>
                <name>ControlStatus</name>
                <addressOffset>0x00</addressOffset>
                <description>Timer Control and Status (Acknowledge Interrupts)</description>
                <size>32</size>
            </register>
            <register>
                <name>Lower32</name>
                <addressOffset>0x04</addressOffset>
                <description>Lower 32 bits of the 64 bit timer</description>
                <size>32</size>
            </register>
            <register>
                <name>Upper32</name>
                <addressOffset>0x08</addressOffset>
                <description>Upper 32 bits of the 64 bit timer</description>
                <size>32</size>
            </register>
            <register>
                <name>Match1</name>
                <addressOffset>0x10</addressOffset>
                <description>Timer Match Register 1</description>
                <size>32</size>
            </register>
            <register>
                <name>Match3</name>
                <addressOffset>0x18</addressOffset>
                <description>Timer Match Register 3</description>
                <size>32</size>
            </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>InterruptController</name>
        <description>
        BCM Interrupt controller (GIC).
        </description>
        <addressBlock>
            <baseAddress>0xB200</baseAddress>
            <size>0x28</size>
            <usage>registers</usage>
        </addressBlock>
        <headerStructName></headerStructName>
        <registers>
            <register>
                <name>BasicPending</name>
                <addressOffset>0x00</addressOffset>
                <description>Basic Interrupt Pending</description>
                <size>32</size>
                <fields>
                    <field>
                        <name>ARMTimer</name>
                        <bitRange>[0:0]</bitRange>
                    </field>
                </fields>
            </register>
            <register>
                <name>Pending1</name>
                <addressOffset>0x04</addressOffset>
                <description>Interrupt Group 1 Pending</description>
                <size>32</size>
            </register>
            <register>
                <name>Pending2</name>
                <addressOffset>0x08</addressOffset>
                <description>Interrupt Group 2 Pending</description>
                <size>32</size>
            </register>
            <register>
                <name>FIQControl</name>
                <addressOffset>0x0C</addressOffset>
                <description>Controls "fast" interrupts</description>
                <size>32</size>
            </register>
            <register>
                <name>EnableIRQs1</name>
                <addressOffset>0x10</addressOffset>
                <description>Enable Group 1 Interrupts</description>
                <size>32</size>
                <fields>
                    <field>
                        <name>AuxInterrupt</name>
                        <description>
                        </description>
                        <access>read-write</access>
                        <bitRange>[29:29]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>EnableIRQs2</name>
                <addressOffset>0x14</addressOffset>
                <description>Enable Group 2 Interrupts</description>
                <size>32</size>
            </register>
            <register>
                <name>EnableBasic</name>
                <addressOffset>0x18</addressOffset>
                <description>Enable Basic Interrupts</description>
                <size>32</size>
                <fields>
                    <field>
                        <name>ARMTimer</name>
                        <bitRange>[0:0]</bitRange>
                    </field>
                </fields>
            </register>
            <register>
                <name>DisableIRQs1 </name>
                <addressOffset>0x1C</addressOffset>
                <description>Disable Group 1 Interrupts</description>
                <size>32</size>
                <fields>
                    <field>
                        <name>AuxInterrupt</name>
                        <description>
                        </description>
                        <access>read-write</access>
                        <bitRange>[29:29]</bitRange>
                        <resetValue>0b0</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>DisableIRQs2</name>
                <addressOffset>0x20</addressOffset>
                <description>Disable Group 2 Interrupts</description>
                <size>32</size>
            </register>
            <register>
                <name>DisableBasic</name>
                <addressOffset>0x24</addressOffset>
                <description>Disable Basic Interrupts</description>
                <size>32</size>
                <fields>
                    <field>
                        <name>ARMTimer</name>
                        <bitRange>[0:0]</bitRange>
                    </field>
                </fields>
            </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>Mailbox</name>
        <description>
        Videocore mailbox interface. inputs must be 16 byte aligned!
        </description>
        <addressBlock>
            <baseAddress>0x0000B880</baseAddress>
            <size>0x24</size>
            <usage>registers</usage>
        </addressBlock>
        <registers>
            <register>
                <name>Read</name>
                <description></description>
                <addressOffset>0x0</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>Poll</name>
                <description></description>
                <addressOffset>0x10</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>Sender</name>
                <description></description>
                <addressOffset>0x14</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>Status</name>
                <description></description>
                <addressOffset>0x18</addressOffset>
                <size>32</size>
                <fields>
                    <field>
                        <name>Full</name>
                        <description>Is the mailbox already full?</description>
                        <access>read-only</access>
                        <bitRange>[31:31]</bitRange>
                        <resetValue>0</resetValue>
                    </field>
                    <field>
                        <name>Empty</name>
                        <description>Is the mailbox empty?</description>
                        <access>read-only</access>
                        <bitRange>[30:30]</bitRange>
                        <resetValue>1</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>Config</name>
                <description></description>
                <addressOffset>0x1C</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>Write</name>
                <description></description>
                <addressOffset>0x20</addressOffset>
                <size>32</size>
            </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>ArmTimer</name>
        <description>
        This is the timer that is on the arm chip.  This is *not* the system
        timer peripheral.  The arm-side timer is document in chapter 14 of the
        BCM2835 manual, whereas the system timer is documented in chapter 12.
        The qemu emulator does not have the match registers for the system timer.
        The arm-side timer requires care to use on real hardware, as it is
        tied to the system clock, whose speed can vary because of low-power
        modes.  You need to either check the clock speed or configure it
        in your config.txt to have a stable value.
        This description has been updated to reflect the errors documented
        in the errata on pages 197 and 198.
        </description>
        <addressBlock>
            <baseAddress>0x000B400</baseAddress>
            <size>0x24</size>
            <usage>registers</usage>
        </addressBlock>
        <registers>
            <register>
                <name>Load</name>
                <description>
                    Timer Load Register. The timer load register sets the time for the timer to count down.
                    This value is loaded into the timer value register after the load register has been written or if the
                    timer-value register has counted down to 0.
                </description>
                <access>read-write</access>
                <addressOffset>0x0</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>Value</name>
                <description>
                    Timer Value Register. This register holds the current timer value and is counted down when the
                    counter is running. It is counted down each timer clock until the value 0 is reached.
                    Then the value register is re-loaded from the timer load register and the interrupt pending bit is
                    set. The timer count down speed is set by the timer pre-divide register.
                </description>
                <access>read-only</access>
                <addressOffset>0x4</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>Control</name>
                <description>
                    Timer Control Register. The standard SP804 timer control register consist of 8 bits but in the
                    BCM implementation there are more control bits for the extra features. Control bits 0-7 are
                    identical to the SP804 bits, albeit some functionality of the SP804 is not implemented.
                    All new control bits start from bit 8 upwards.
                </description>
                <access>read-write</access>
                <addressOffset>0x8</addressOffset>
                <size>32</size>
                <fields>
                    <field>
                        <name>PreScaler</name>
                        <description>
                        Free running counter pre-scaler. Freq is sys_clk/(prescale+1)
                        </description>
                        <bitRange>[23:16]</bitRange>
                        <resetValue>0x3E</resetValue>
                    </field>
                    <field>
                        <name>FreeRunningEnableDisable</name>
                        <description>
                        0 : Free running counter Disabled
                        1 : Free running counter Enabled
                        </description>
                        <bitRange>[9:9]</bitRange>
                    </field>
                    <field>
                        <name>HaltOnDebug</name>
                        <description>
                        0 : Timers keeps running if ARM is in debug halted mode
                        1 : Timers halted if ARM is in debug halted mode
                        </description>
                        <bitRange>[8:8]</bitRange>
                    </field>
                    <field>
                        <name>CounterEnableDisable</name>
                        <description>
                        0 : Timer disabled
                        1 : Timer enabled
                        </description>
                        <bitRange>[7:7]</bitRange>
                    </field>
                    <field>
                        <name>InterruptEnableDisable</name>
                        <description>
                        0 : Timer Interrupt disabled
                        1 : Timer Interrupt enabled
                        </description>
                        <bitRange>[5:5]</bitRange>
                    </field>
                    <field>
                        <name>Prescale</name>
                        <description>
                        00 : pre-scale is clock / 1 (No pre-scale)
                        01 : pre-scale is clock / 16
                        10 : pre-scale is clock / 256
                        11 : pre-scale is clock / 1 (Undefined in 804)
                        </description>
                        <bitRange>[3:2]</bitRange>
                        <enumeratedValues>
                            <enumeratedValue>
                                <name>NoPreScale</name>
                                <value>0b00</value>
                                <description>prescale is clock/1</description>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>PreScale16</name>
                                <value>0b01</value>
                                <description>prescale is clock/16</description>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>PreScale256</name>
                                <value>0b10</value>
                                <description>prescale is clock/256</description>
                            </enumeratedValue>
                        </enumeratedValues>
                    </field>
                    <field>
                        <name>CounterSize</name>
                        <description>
                        0 : 16-bit counters
                        1 : 32-bit counter
                        </description>
                        <bitRange>[1:1]</bitRange>
                        <enumeratedValues>
                            <enumeratedValue>
                                <name>SixteenBit</name>
                                <value>0b0</value>
                            </enumeratedValue>
                            <enumeratedValue>
                                <name>ThirtyTwoBit</name>
                                <value>0b1</value>
                            </enumeratedValue>
                        </enumeratedValues>
                    </field>
                </fields>
            </register>
            <register>
                <name>IRQClear</name>
                <description>
                The timer IRQ clear register is write only. When writing this register the interrupt-pending bit is cleared.
                When reading this register it returns 0x544D5241 which is the ASCII reversed value for "ARMT".
                </description>
                <access>write-only</access>
                <addressOffset>0x0C</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>RawIRQStatus</name>
                <description>
                It shows the status of the interrupt pending bit.
                </description>
                <access>read-only</access>
                <addressOffset>0x10</addressOffset>
                <size>32</size>
                <fields>
                    <field>
                    <name>Pending</name>
                    <bitRange>[0:0]</bitRange>
                    </field>
                </fields>
            </register>
            <register>
                <name>MaskedIRQStatus</name>
                <description>
                The masked IRQ register is a read-only register. It shows the status of the interrupt signal. It is
                simply a logical AND of the interrupt pending bit and the interrupt enable bit.
                </description>
                <access>read-only</access>
                <addressOffset>0x14</addressOffset>
                <size>32</size>
                <fields>
                    <field>
                    <name>Asserted</name>
                    <bitRange>[0:0]</bitRange>
                    </field>
                </fields>
            </register>
            <register>
                <name>Reload</name>
                <description>
                This register is a copy of the timer load register. The difference is that a write to this register
                does not trigger an immediate reload of the timer value register. Instead the timer load register
                value is only accessed if the value register has finished counting down to zero.
                </description>
                <access>read-write</access>
                <addressOffset>0x18</addressOffset>
                <size>32</size>
            </register>
            <register>
                <name>PreDivide</name>
                <description>
                The Pre-divider register is not present in the SP804.  Compensates for the lack of a 1Mhz clock.
                </description>
                <access>read-write</access>
                <addressOffset>0x1C</addressOffset>
                <size>32</size>
                <fields>
                    <field>
                        <name>Value</name>
                        <description>
                        The pre-divider register is 10 bits wide and can be written or read from. This register has
                        been added as the SP804 expects a 1MHz clock which we do not have. Instead the pre-divider
                        takes the APB clock and divides it down according to:
                        timer_clock = apb_clock/(pre_divider+1)
                        The reset value of this register is 0x7D so gives a divide by 126.
                        </description>
                        <bitRange>[9:0]</bitRange>
                        <resetValue>0x7D</resetValue>
                    </field>
                </fields>
            </register>
            <register>
                <name>Counter</name>
                <description>
                 The free running counter is not present in the SP804.
                 The free running counter is a 32 bits wide read only register. The register is enabled by setting bit
                 9 of the Timer control register. The free running counter is incremented immediately after it is
                 enabled. The timer can not be reset but when enabled, will always increment and roll-over. The free
                 running counter is also running from the APB clock and has its own clock pre-divider controlled by
                 bits 16-23 of the timer control register.
                 This register will be halted too if bit 8 of the control register is set and the ARM is in Debug Halt mode.
                </description>
                <access>read-only</access>
                <addressOffset>0x20</addressOffset>
                <size>32</size>
            </register>
        </registers>
    </peripheral>
  </peripherals>
</device>
